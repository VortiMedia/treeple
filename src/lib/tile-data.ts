import { Tile, GridData, SeedData } from '@/types';
import { DEFAULT_TILE_PRICE } from '@/constants/colors';

/**
 * Load the Yellowstone grid GeoJSON data
 */
export async function loadGridData(): Promise<GridData> {
  try {
    console.log('Loading grid data from /data/yellowstone-grid.json');

    const response = await fetch('/data/yellowstone-grid.json');

    console.log(`Grid data response: ${response.status} ${response.statusText} (${response.headers.get('content-type')})`);

    if (!response.ok) {
      throw new Error(
        `Failed to load grid data: ${response.status} ${response.statusText}\n` +
        'Make sure the grid data has been generated by running: npm run generate-grid'
      );
    }

    const data = await response.json();

    if (!data.features || data.features.length === 0) {
      throw new Error(
        'Grid data is empty or invalid. Please regenerate by running: npm run generate-grid'
      );
    }

    console.log(`✓ Loaded ${data.features.length} grid tiles`);

    // Check for duplicate IDs (detect corruption issue)
    const idSet = new Set();
    let duplicateFound = false;
    data.features.forEach((feature: any) => {
      if (idSet.has(feature.properties.id)) {
        duplicateFound = true;
      }
      idSet.add(feature.properties.id);
    });

    if (duplicateFound || idSet.size === 1) {
      throw new Error(
        'Grid data is corrupted (duplicate tile IDs detected). Please regenerate by running: npm run generate-grid'
      );
    }

    return data;
  } catch (error) {
    console.error('Error loading grid data:', error);
    throw error;
  }
}

/**
 * Load the seed tile status data
 */
export async function loadSeedData(): Promise<SeedData> {
  try {
    console.log('Loading seed data from /data/seed-tiles.json');

    const response = await fetch('/data/seed-tiles.json');

    // Seed data is optional, so 404 is not an error
    if (response.status === 404) {
      console.warn('⚠️  Seed data file not found (this is optional). Using default tile states.');
      return {};
    }

    if (!response.ok) {
      throw new Error(`Failed to load seed data: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const seedCount = Object.keys(data).length;
    console.log(`✓ Loaded ${seedCount} seeded tiles`);

    return data;
  } catch (error) {
    // If it's a 404, we already handled it above, so this is a different error
    if (error instanceof Error && error.message.includes('404')) {
      return {};
    }
    console.error('Error loading seed data:', error);
    throw error;
  }
}

/**
 * Merge grid data with seed status overrides
 */
export function mergeTileData(gridData: GridData, seedData: SeedData): Map<string, Tile> {
  const tileMap = new Map<string, Tile>();
  const seedCount = Object.keys(seedData).length;

  console.log(`Merging ${gridData.features.length} grid tiles with ${seedCount} seed overrides`);

  // Track duplicate IDs during merge
  const seenIds = new Set<string>();
  let duplicates = 0;

  gridData.features.forEach((feature) => {
    const tileId = feature.properties.id;

    // Check for duplicates
    if (seenIds.has(tileId)) {
      duplicates++;
      return; // Skip duplicates
    }
    seenIds.add(tileId);

    const seedStatus = seedData[tileId];

    const tile: Tile = {
      id: tileId,
      coordinates: feature.properties.coordinates,
      status: seedStatus?.status || feature.properties.status,
      geometry: feature.geometry,
      price: seedStatus?.price || DEFAULT_TILE_PRICE,
      ...(seedStatus?.reservedAt && { reservedAt: seedStatus.reservedAt }),
      ...(seedStatus?.soldAt && { soldAt: seedStatus.soldAt }),
      // Include donor metadata for visual patterns
      ...(seedStatus?.donor && { donor: seedStatus.donor }),
      ...(seedStatus?.pattern && { pattern: seedStatus.pattern }),
      ...(seedStatus?.message && { message: seedStatus.message }),
      ...(seedStatus?.visibility && { visibility: seedStatus.visibility })
    };

    tileMap.set(tileId, tile);
  });

  if (duplicates > 0) {
    console.warn(`⚠️  Skipped ${duplicates} duplicate tile IDs during merge`);
  }

  // Warn about seed data that references non-existent tiles
  const orphanedSeeds = Object.keys(seedData).filter(id => !tileMap.has(id));
  if (orphanedSeeds.length > 0) {
    console.warn(`⚠️  ${orphanedSeeds.length} seed entries reference tiles that don't exist in the grid`);
  }

  console.log(`✓ Created tile map with ${tileMap.size} unique tiles`);

  return tileMap;
}

/**
 * Get a specific tile by ID
 */
export function getTileById(tileMap: Map<string, Tile>, tileId: string): Tile | undefined {
  return tileMap.get(tileId);
}

/**
 * Calculate statistics for tile statuses
 */
export function getTileStats(tileMap: Map<string, Tile>) {
  const stats = {
    total: tileMap.size,
    available: 0,
    reserved: 0,
    sold: 0
  };

  tileMap.forEach((tile) => {
    stats[tile.status]++;
  });

  return stats;
}
